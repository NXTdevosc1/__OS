
UINT64 NumReadyThreads[NUM_PRIORITY_CLASSES] // on each priority class
LPVOID ThreadQueues[NUM_PRIORITY_CLASSES]
RFTHREAD SelectedThread; // Highest priority thread found on this scheduling queue
UINT64 TotalClocks // Total Clocks of the timer
UINT64 ReadyOnClock[NUM_PRIORITY_CLASS] // The most ready thread will be on this clock
UINT64 HighestPriority[NUM_PRIORITY_CLASS] // Highest priority between all present threads 
(including non-ready threads)

UINT128 InterruptTime; // The record HPET Time at the interrupt (to prevent recalculation on each asleep thread)

Work:
	
STEP 1:

- Examine arranged NumThreads of the same or highest priority
{
	where i = Current Priority; i++
	if NumThreads then : {
		for i = 0; i<NumThreads, i++, thread++
			if thread.Priority > Current Priority && thread.ReadyOnClock >= TotalClocks:
				if(thread.Priority == HighestPriority) DispatchThread
				else SelectedThread = thread;
		
		// There must be a selected thread otherwise we wan't a pagefault (this will signal a bug or a forgot-to-set value)
		DispatchThread
	}
}
- if no ready thread is found then search lower priority threads
- if no thread is ready then run idle thread
{
	mov [SelectedThread], [CPM /*Cpu Management Table*/ + IdleThread]
	DispatchThread
	
}

; Perform double operation with xmm0-xmm3

; XMM0 : NUM_READY_THREADS [RCX]
; XMM1 : THREAD_QUEUES [RDX]
; XMM2 : READY_ON_CLOCK 128 BIT Per value [R8]
; XMM3 : HIGHEST_PRIORITY_THREAD [R9]
; XMM4 : Total Clocks
; XMM15 [MM6]:MM0 : Total Threads [R13]
; XMM13 : High Precision Time
; MM5 : Thread Priority Class
; R15 = Index
; rbx : Selected Thread
;
; A0L0 : Test if there is higher priority runnable threads
; A0R0 : Test if the thread is runnable (if there is no higher priority runnable threads)
; A0L1 : If not then search for lower priority runnable threads



