#include <timedate/rtc.h>
#include <preos_renderer.h>
#include <cstr.h>
#include <interrupt_manager/idt.h>
#include <Management/runtimesymbols.h>
#include <CPU/cpu.h>
#include <CPU/process.h>
#include <interrupt_manager/SOD.h>
char* WeekDays[] = {0, "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"};

#define RTC_GETTIME 0
#define RTC_SETTIME 1
#define RTC_UPDATECLOCK 2 // Generated by interrupt handler only

RTC_TIME_DATE RtcTimeDate = {0};

#define RTC_CONVERT_BYTE(Byte) ((RtcTimeDate.ByteFormat == 1) ? Byte : RTC_BCD_TO_BINARY(Byte))

void RtcUpdate();

RFTHREAD RtcClientThread = NULL;
BOOL Updating = FALSE;
void RtcClient(){
	SetThreadPriority(RtcClientThread, THREAD_PRIORITY_HIGH);
	MSG Message = {0};
	MSG_HEADER Header = {0};
	while(IpcGetMessage(RtcClientThread->Client, &Message)){
		KERNELSTATUS Status = KERNEL_SERR;
		IpcQueryMessageHeader(RtcClientThread->Client, &Header);
		switch(Message.Message){
			case RTC_GETTIME:
			{
				void* Packet = IpcGetMessagePacket(RtcClientThread->Client);
				
				if(!Packet || Message.NumBytes != sizeof(RTC_TIME_DATE)){
					Status = KERNEL_SERR_INVALID_PARAMETER;
					break;
				}
				memcpy(Message.Data, &RtcTimeDate, sizeof(RTC_TIME_DATE));
				Status = KERNEL_SOK;
				break;
			}
			case RTC_SETTIME:
			{
				Status = KERNEL_SERR_UNSUPPORTED;
				break;
			}
			case RTC_UPDATECLOCK:
			{
				if(Header.Source->Process == kproc) {
					RtcUpdate();
					Status = KERNEL_SOK;
				}
				break;
			}
		}
		IpcSetStatus(RtcClientThread->Client, Status);
		IpcMessageDispatch(RtcClientThread->Client);
	}
	SOD(0, "IPC ROUNTINE FAILURE UNCAUGHT ERROR MADE IPC GET MESSAGE == 0");
}

void RtcUpdate(){
	
	
}

void RtcInterruptHandler(RFDRIVER_OBJECT DriverObject, RFINTERRUPT_INFORMATION InterruptInformation){
	while(isRtcUpdating());
	Updating = TRUE;
	RtcTimeDate.Second = RTC_CONVERT_BYTE(CmosRead(RTC_SECONDS));
	RtcTimeDate.Minute = RTC_CONVERT_BYTE(CmosRead(RTC_MINUTES));
	
	unsigned char Hours = CmosRead(RTC_HOURS);
	unsigned char ConvertedHours = RTC_CONVERT_BYTE(Hours & ~0x80);
	RtcTimeDate.RtcHour = (Hours & 0x80) | ConvertedHours;
	if(!RtcTimeDate.HourFormat){
		// 12H Hour format
		if(Hours & 0x80 && ConvertedHours != 12){
			// 1+ PM
			RtcTimeDate.Hour = ConvertedHours + 12;
		}else if(!(Hours & 0x80) && ConvertedHours == 12){
			RtcTimeDate.Hour = 0;
		}else{
			RtcTimeDate.Hour = ConvertedHours;
		}
	}else{
		RtcTimeDate.Hour = RTC_CONVERT_BYTE((Hours & ~(0x80)));
	}
	RtcTimeDate.WeekDay = RTC_CONVERT_BYTE(CmosRead(RTC_WEEKDAY));
	RtcTimeDate.DayOfMonth = RTC_CONVERT_BYTE(CmosRead(RTC_DAYOF_MONTH));
	RtcTimeDate.Month = RTC_CONVERT_BYTE(CmosRead(RTC_MONTH));
	RtcTimeDate.YearOfCentury = RTC_CONVERT_BYTE(CmosRead(RTC_YEAR));
	RtcTimeDate.Year = 2000 + RtcTimeDate.YearOfCentury;
	Updating = FALSE;
	// Send EOI to CMOS
	CmosRead(RTC_STATUS_REGISTERC); // read register C (Interrupt Type) to produce new RTC Interrupt
	// Send EOI To IOAPIC
}

UINT RTCDivider = 15; // interrupt at 1khz (0x8000 >> (6 - 1))

KERNELSTATUS RtcGetTimeAndDate(RTC_TIME_DATE* TimeDate){
	if(!TimeDate) return KERNEL_SERR_INVALID_PARAMETER;
	while(Updating);
	memcpy(TimeDate, &RtcTimeDate, sizeof(RTC_TIME_DATE));
	
	// return IpcSendMessage(GetCurrentThread()->Client, RtcClientThread->Client, FALSE, RTC_GETTIME, TimeDate, sizeof(RTC_TIME_DATE));
	return KERNEL_SOK;
}

KERNELSTATUS RtcSetTimeAndDate(RTC_TIME_DATE* TimeDate){
	return IpcSendMessage(KeGetCurrentThread()->Client, RtcClientThread->Client, FALSE, RTC_SETTIME, TimeDate, sizeof(RTC_TIME_DATE));
}

void RtcInit(){
	// Enable RTC
	RtcClientThread = KeCreateThread(kproc, 0x2000, RtcClient, 0, 0);
	if(!RtcClientThread) SET_SOD_INITIALIZATION;

	// if(KeControlIrq(RtcInterruptHandler, 8, IRQ_DELIVERY_NORMAL, 0) != KERNEL_SOK) SET_SOD_INITIALIZATION;

	// unsigned char prev = 0;
	// Set Frequency
	// prev = CmosRead(0x8A);
	// CmosWrite(0x8A, (prev & 0xF0) | RTCDivider);

	// Get Hour & Byte Format
	unsigned char StatusRegisterB = CmosRead(0x8B);
	if(StatusRegisterB & 2) RtcTimeDate.HourFormat = 1; // 24 Hour format
	if(StatusRegisterB & 4) RtcTimeDate.ByteFormat = 1; // Binary (Decimal) Mode
	// Enable the timer
	// prev = CmosRead(0x8B);
	// CmosWrite(0x8B, prev | 0x40);
}

BOOL isRtcUpdating(){
	if(CmosRead(0xA) & 0x80) return TRUE;

	return FALSE;
}